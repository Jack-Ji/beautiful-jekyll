---
layout: post
title: Scheme语言-Chapter 2-起步
bigimg: /img/John-McCarthy.jpg
tags: [scheme]
---

本章的目的是向Scheme新手介绍这门语言，强烈建议阅读本章的读者自己将所有代码例子运行一遍。

阅读完本章并完成习题后，你将学会Scheme的基本语法和运行方式，此外还会了解一些简单的数据结构和控制语句的用法。
实际上，在熟悉了上述内容后，你就可以尝试进行Scheme编程了！

## Scheme交互环境

在上一章中提到过，大部分Scheme实现都提供了交互式的开发环境，这使我们能够很方便的对代码进行实验分析。
Scheme的交互环境基于“read-evaluate-print”循环，这个循环机制经常被称为`REPL`。
顾名思义，REPL在每个循环中所做的事情就是读取输入、计算输入的表达式和输出计算结果。

利用Scheme的交互环境，程序师可以在输入表达式后立刻观察其运行结果；你可以在定义好一个函数后马上对其进行调用，
以观察其表现是否符合预期；你甚至可以将包含多个函数、变量定义的程序整个输入进去，然后好整以暇的对其进行测试和调试。
随着程序规模的增加，我们可以将程序保存至文件中，然后在交互环境中将源文件导入并测试。
大部分Scheme实现都提供了非标准的`load`函数，该函数可用于从文件系统中加载源代码文件。
实际上无论代码是来自文件还是用户输入，对Scheme来讲没有任何区别，文件只是方便我们保存、阅读和修改程序的手段而已。

本文的实例代码都采用了美化过的缩进方式，目的是为了清晰的展示出程序的结构。
采用什么样的代码风格不重要，关键是确立一种然后坚持用下去。
当然Scheme是不在乎你的代码风格的，它实际上将所有代码看作为一行从左至右进行处理的文本！

现在你可以打开自己的Scheme实现进行学习了！首先我们输入：`"Hi Mom!"`，注意双引号也需要输入。
可以看到，Scheme马上输出了同样的字符串：`"Hi Mom!"`。**在Scheme中，任何常量表达式的值仍然是它本身。**

下面给出了更多示例，`=>`后面给出了Scheme对每个表达式进行计算的结果，我们会在后面描述各种表达式的具体含义。

```
"hello" => "hello"
42 => 42
22/7 => 22/7
3.141592653 => 3.141592653
+ => #<procedure +>
(+ 76 31) => 107
(* -12 10) => -12
'(a b c d) => (a b c d)
```

下面是更多的示例，你可以尝试猜一下各个表达式的含义，然后继续阅读看看你想得是否正确：）。

```
(car '(a b c)) => a
(cdr '(a b c)) => (b c)
(cons 'a '(b c)) => (a b c)
(cons (car '(a b c))
      (cdr '(d e f))) => (a e f)
```

如你所见，用户输入的Scheme表达式可以跨越多行，Scheme通过匹配双引号和左右括号得知表达式是否读取完毕。

接下来让我们尝试定义一个函数：

```scheme
(define square
    (lambda (n)
        (* n n)))
```

函数`square`的功能是计算输入的平方。我们将在后续章节中详细描述这个函数的定义方式，
目前你只需要知道`define`创建了一个变量，`lambda`创建了一个函数、`*`则代表了乘法操作。
需要值得注意的是所有表达式都被括号包围，并且都采用了前缀表达式，即操作符在参数之前。

下面我们尝试调用`square`函数：

```
(square 5) => 25
(square -200) => 40000
(square 0.5) => 0.25
(square -1/2) => 1/4
```

下面是另外一个函数定义，尽管这是一段很小的代码，我们仍然可以将它保存至文件中，假设文件被命名为“reciprocal.ss”。

```scheme
(define reciprocal
    (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
```

函数`reciprocal`的功能是给定某个数`n`，返回值`1/n`。如果`n`的值为0，则返回字符串`"oops!"`。
下面我们通过`load`函数加载文件并对函数进行测试：

```
(load "reciprocal.ss")

(reciprocal 10) => 1/10
(reciprocal 1/10) => 10
(reciprocal 0) => "oops"
(reciprocal (reciprocal 1/10)) => 1/10
```

我们在下一节会进一步讲述表达式。再强调一次，Scheme交互环境是学习Scheme语言的最好帮手，
请尽量尝试自己去运行本文的每个例子，对Scheme来说这几乎不消耗什么时间，你只需要花点时间敲字就行了：）。

## 简单表达式

Scheme中最简单的表达式是常量数据对象，例如：字符串、数字、符号和list。
尽管Scheme还支持其它数据类型，以上4种对很多程序来讲已经够用了。我们在上面的实例中已经用到了字符串和数字两种数据类型。

现在让我们进一步深入了解数字。首先，数字是常量，当你向Scheme输入数字时，它会将数字原原本本的返还给你。
下面给出了Scheme支持的几种数字类型的写法：

```
1231281249172381 => 1231281249172381
3/4 => 3/4
2.718901293 => 2.718901293
2.2+1.1i => 2.2+1.1i
```

Scheme中的数字种类有整数、有理数、实数和复数，每种数字类型又分精确和非精确两种表示方法。
精确的整数和有理数可以达到任意精度和大小（受限于内存）。而非精确的数字则在内部使用了IEEE浮点数表示法。

![数字定义](../img/tspl/number-definitions.jpg)

Scheme提供了4种基本运算操作符+、-、*、/，分别对应加法、减法、乘法和除法运算。下面是使用运算符的实例：

```
(+ 1/2 1/2) => 1
(- 1.5 1/2) => 1.0

(* 3 1/2) => 3/2
(/ 1.5 3/4) => 2.0
```

Scheme中的所有操作表达式均采用了前缀写法，无论一个操作符或函数接受多少参数，统一全部使用`(procedure arg ...)`这样的写法。
这样处理一方面简化了表达式的语法结构，另一方面也避免了对符号优先级做特殊处理。

操作符/函数调用是可以被嵌套到一起的，最内层的操作符/函数调用会首先被处理，然后其返回结果会被作为外层调用的参数，以此类推。
下面是利用嵌套方式进行的稍复杂点的运算：

```
(+ (+ 2 2) (+ 2 2)) => 8
(- 2 (* 4 1/3)) => 2/3
(* 2 (* 2 (* 2 (* 2 2)))) => 32
(/ (* 6/7 7/2) (- 4.5 1.5)) => 1.0
```

了解了以上内容，你已经可以将Scheme当做一个标准的计算器来使用了！
更多的高级运算函数，如开方、三角函数、log运算等会在第6章中统一介绍，当然你也可以提前尝试运行看看效果：）。

尽管我们可以使用简单的数字运算完成很多工作，偶尔我们还是需要能保存多个值的复合数据类型。
在很多其它编程语言中，最基本的符合数据类型是数组。而Scheme中最基本的符合类型则是list。
list是用括号包围起来的数据序列，例如：(1 2 3 4 5)是一个包含数字的list、("this" "is" "a" "list")是一个包含字符串的list。
list可以包含不同类型的数据，例如`(4.2 "hi")`就是一个包含数字和一个字符串的list。
一个list同样可以包含其它list，例如`((1 2) (3 4))`就是一个包含两个元素的list，每个元素都是包含两个数字的list。

你也许注意到了list的结构和操作符/函数调用是一样的，那么Scheme如何对它们做区分呢？

有些情况是很容易做区分的，比如一个元素为数字的list：`(1 2 3 4 5)`，很明显这不可能是某个调用语句。
由此看来，Scheme只需判断list的第一个元素是否为操作符或函数，从而得知该list是否为调用语句。那么事实是否如此呢？
很遗憾，没那么简单。假如我们有一个list的元素是`(+ 3 4)`，上面的方法就行不通了。
真正的答案是必须由我们自己来告诉Scheme某个list是数据还是调用语句。我们通过`quote`操作符来实现这一点：

```
(quote (1 2 3 4 5)) => (1 2 3 4 5)
(quote ("This" "is" "a" "list")) => ("This" "is" "a" "list")
(quote (+ 3 4)) => (+ 3 4)
```

使用`quote`可以使Scheme将某个list看作为数据。如果将上面代码中的`quote`去掉，前两条表达式会抛出异常，最后一条会给出错误结果`7`。

由于`quote`的使用频率相当高，Scheme专门为其提供了一种简写方式：在list前面添加单引号。

```
'(1 2 3 4) => (1 2 3 4)
'((1 2) (3 4)) => ((1 2) (3 4))
'(/ (* 2 -1) 3) => (/ (* 2 -1) 3)
```

以上两种写法都被称为引用表达式——如果一个对象被`quote`表达式包围，我们就称其被引用了。

需要注意的是`quote`不是函数调用，否则被引用的list仍然会被求值。`quote`实际上是Scheme的特殊操作符，它禁止了Scheme对其子项进行求值。
Scheme还有其它特殊操作符，每个都有其特殊的含义和求值方式。幸运的是，特殊操作符的数目并不多，后面我们会一一见到。

`quote`不仅可以引用list，看下面的表达式（请尝试不用quote看看结果）：

```
(quote hello) => hello
```

hello必须被引用才会被Scheme看作为符号，否则Scheme会将其看作为变量。符号与变量的关系常使人觉得困惑。
符号只有名称，没有任何关联的值，作用域为全局；而变量则不光有名称，还有关联的值，作用域则视情况而定。
当我们根据`x`的当前值计算数学表达式`x + 1`的结果时，`x`就是一个变量。
当我们分析方程`x^2 - 1 = (x - 1)(x + 1)`时，`x`就是一个符号，因为在这里`x`只是一个代号，它的值我们并不关心。
符号通常被用于在方程或程序的符号化表示中代表某个变量，此外也可被用于在自然语言语句中代表某个单词。

你也许想问为什么调用表达式和变量分别采用了与list和符号相同的写法（需要通过`quote`告诉Scheme到底是那种类型），
这样做的好处就是Scheme程序可以被非常容易的用Scheme数据来表示，这在我们编写解释器、编译器和编辑器等工具时起到的作用相当大。
我们将会在第12章中用Scheme来编写一个Scheme解释器，如果你能够耐心的读到那里，相信你一定能深深得体会到上面所说的好处。

数字和字符串也可以被引用：

```
'2 => 2
'2/3 => 2/3
(quote "Hi Mom!") => "Hi Mom!"
```

对数字和字符串进行引用是没有必要的，因为它们被Scheme视为常量，它们的值就是自身。

现在让我们来讨论Scheme提供的操作list的函数。
首先来看最基本的两个函数：`car`和`cdr`，`car`返回list的第一个元素，`cdr`则将剩下的返回。
`car`和`cdr`这两个奇怪的名字来自于第一台实现了Lisp的机器——IBM 704，感兴趣的可去google。
`car`和`cdr`的参数都必须是非空的list：

```
(car '(a b c)) => a
(cdr '(a b c)) => (b c)
(cdr '(a)) => ()

(car (cdr '(a b c))) => b
(cdr (cdr '(a b c))) => (c)

(car '((a b) (c d))) => (a b)
(cdr '((a b) (c d))) => ((c d))
```

list的第一个元素通常被称为`list的car`，而list剩下的部分则被称为`list的cdr`。只有一个元素的list的cdr是空list。

函数`cons`可用来构建list，它接受两个参数，在第二个参数是list的情况下该函数会返回新创建的list。

```
(cons 'a '()) => (a)
(cons 'a '(b c)) => (a b c)
(cons 'a (cons 'b (cons 'c '()))) => (a b c)
(cons '(a b) '(c d)) => ((a b) c d)

(car (cons 'a '(b c))) => a
(cdr (cons 'a '(b c))) => (b c)
(cons (car '(a b c))
      (cdr '(d e f))) => (a e f)
```

实际上`cons`的第二个参数并非一定要list类型，`cons`的功能是将两个值组合成为一个`pair`（一对数据的简称），
而Scheme并没有规定`pair`的第二个元素（也就是`cdr`）必须是list！
一个list实际上就是多个`pair`构成的序列，其中每个`pair`的`cdr`都指向序列中的下一个`pair`。

![list表示](../img/tspl/list-1.png)

可以看到，以上序列的最后一个`pair`的`cdr`是空list，这是该序列构成一个合法list的必要条件。
更为正式的讲，空list或者任何`cdr`为list的`pair`都是合法的list。

Scheme使用`dotted-pair`写法来表示一个不是list的pair，具体做法就是在最后一个元素的前面加一个`.`。

```
(cons 'a 'b) => (a . b)
(cdr '(a . b)) => b
(cons 'a '(b . c)) => (a b . c)
```

实际上合法的list也可以使用`dotted-pair`表示法，只不过Scheme总会将其转换为正式的list表示。

```
'(a . (b . (c . ()))) => (a b c)
'(a b c . ()) => (a b c)
```

函数`list`的作用与`cons`类似，不过它可以接受任意数目的参数，并且总是返回合法的list。

```
(list 'a 'b 'c) => (a b c)
(list 'a) => (a)
(list) => ()
```

第6章节会介绍更多list的操作函数，感兴趣的读者可以提前跳过去学习。

#### [习题及解答](https://github.com/jack-ji/scheme-ex/blob/master/tspl/2-2.ss)

## Scheme表达式的求值过程

下面我们讨论Scheme对表达式进行求值的过程。之前我们已经明确过常量对象的值是它本身，例如字符串和数字。
接下来让我们考虑典型的调用语句`(procedure arg1 ... argn)`，其中`procedure`代表值为操作符或函数的表达式，
`arg1 ... argn`代表参数。一种可能的求值过程如下（可能跟你所想的差不多）：

* 计算`procedure`的值；
* 计算`arg1`的值；
...
* 计算`argn`的值；
* 将计算得出的值传递给`procedure`；

让我们按照以上流程来考虑表达式`(+ 3 4)`。
首先`+`的值为加法运算子程序，3的值为3，4的值为4，然后将3和4传递给加法运算子程序，我们就得到了结果7。

以上求值流程可以被运用到表达式的每个字句中。让我们再来考虑嵌套表达式`(* (+ 3 4) 2)`。
`*`的值是乘法运算子程序，`(+ 3 4)`的值我们已经分析过了是7，2的值是2，最后将7和2相乘就得到了最终结果14。

很遗憾，以上求值过程只能适用于普通的函数调用语句，在调用特殊操作符的情形下就不再适用了。
以引用操作符`quote`为例，它不会对其参数进行求值，其表现有点类似常量——`(quote object)`的值就是`object`。

常量、函数调用和`quote`表达式仅仅是Scheme提供的多种语法表达式的一部分。
幸运的是Scheme开发者并不需要熟悉它们全部，我们需要深入理解的只是它们的一小部分，这部分一般被为核心语法表达式。
其它语法表达式实际上都是在核心语法表达式的基础上做的扩展。我们会在本章接下来的内容中介绍其它核心语法表达式和部分语法扩展。
第3章将给出一个所有核心表达式的汇总，并且正式介绍Scheme的语法扩展功能。

在继续学习其它核心表达式之前，我们需要特别提出关于表达式求值的两点信息：

1. Scheme对调用参数的求值顺序并不总是像上面给出的流程那样从左至右的，Scheme可能以任意的顺序去求值，
   甚至同一程序内对同一个函数的两次调用所采用的求值顺序都不尽相同；
2. 尽管`procedure`通常是一个值为某个函数的变量，实际上它同样可以是一个调用表达式，只要其最终求值结果为函数即可。
   例如：表达式`((car (list + - * /)) 2 3)`所做的事情其实就是将2和3相加，`(car (list + - * /))`就代表了`+`操作符；

## 变量和`let`表达式
